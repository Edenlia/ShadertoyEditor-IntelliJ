<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Shadertoy Renderer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        
        #canvas {
            display: block;
            /* 宽高由JavaScript控制，不在CSS中固定 */
        }
        
        /* 性能监控面板 */
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00ff00;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 1px solid #00ff00;
            border-radius: 4px;
            user-select: none;
            z-index: 1000;
        }
        
        #stats div {
            margin: 2px 0;
        }
        
        /* 错误显示 */
        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff3333;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border: 2px solid #ff3333;
            border-radius: 8px;
            max-width: 80%;
            max-height: 80%;
            overflow: auto;
            white-space: pre-wrap;
            display: none;
            z-index: 2000;
        }
        
        #error .error-title {
            color: #ff6666;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <!-- 性能统计 -->
    <div id="stats">
        <div id="fps">FPS: 0</div>
        <div id="frametime">Frame: 0.0ms</div>
        <div id="compiletime">Compile: 0.0ms</div>
    </div>
    
    <!-- 错误显示 -->
    <div id="error">
        <div class="error-title">Shader Compilation Error</div>
        <div id="error-message"></div>
    </div>
    
    <!-- Vertex Shader: WebGL 2 with gl_VertexID magic -->
    <script id="vertexShader" type="x-shader/x-vertex">#version 300 es
void main() {
    // Generate fullscreen quad vertices using gl_VertexID
    // No vertex buffer needed!
    float x = float((gl_VertexID & 1) << 2);
    float y = float((gl_VertexID & 2) << 1);
    gl_Position = vec4(x - 1.0, y - 1.0, 0, 1);
}
</script>
    
    <!-- Default Fragment Shader: Classic Shadertoy gradient -->
    <script id="fragmentShader" type="x-shader/x-fragment">#version 300 es
precision highp float;

uniform vec3 iResolution;
uniform float iTime;
uniform float iTimeDelta;
uniform int iFrame;
uniform vec4 iMouse;
uniform vec4 iDate;

out vec4 fragColor;

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord / iResolution.xy;
    
    // Classic Shadertoy color gradient
    vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0.0, 2.0, 4.0));
    
    // Output to screen
    fragColor = vec4(col, 1.0);
}

void main() {
    mainImage(fragColor, gl_FragCoord.xy);
}
</script>
    
    <script>
        // ===== WebGL Initialization =====
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2', { 
            antialias: true, 
            preserveDrawingBuffer: true 
        });
        
        if (!gl) {
            showError('WebGL 2 is not supported in this browser.\nPlease upgrade your IDE to a version that supports WebGL 2.');
            throw new Error('WebGL 2 not supported');
        }
        
        // ===== Stats Elements =====
        const fpsElement = document.getElementById('fps');
        const frametimeElement = document.getElementById('frametime');
        const compiletimeElement = document.getElementById('compiletime');
        const errorElement = document.getElementById('error');
        const errorMessageElement = document.getElementById('error-message');
        
        // ===== Shader State =====
        let program = null;
        let uniforms = {};
        let startTime = performance.now();
        let lastFrameTime = performance.now();
        let frameCounter = 0;
        let fpsFrameCount = 0;
        let lastFpsUpdate = performance.now();
        let currentFps = 0;
        let currentFrameTime = 0;
        
        // ===== Canvas Size Management =====
        
        // 目标分辨率（默认值，会被Settings覆盖）
        let targetWidth = 1280;
        let targetHeight = 720;
        
        /**
         * 根据目标分辨率和窗口大小计算canvas尺寸
         * 策略：Always fit（保持aspect ratio，完全显示在窗口内）
         */
        function resizeCanvas() {
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // 计算aspect ratio
            const targetAspect = targetWidth / targetHeight;
            const windowAspect = windowWidth / windowHeight;
            
            let canvasWidth, canvasHeight;
            
            // 根据窗口和目标的aspect ratio选择适配策略
            if (windowAspect > targetAspect) {
                // 窗口更宽，高度受限
                canvasHeight = windowHeight;
                canvasWidth = Math.round(windowHeight * targetAspect);
            } else {
                // 窗口更高，宽度受限
                canvasWidth = windowWidth;
                canvasHeight = Math.round(windowWidth / targetAspect);
            }
            
            // 设置canvas内部分辨率（WebGL渲染分辨率）
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            gl.viewport(0, 0, canvasWidth, canvasHeight);
            
            // 设置CSS显示尺寸（1:1匹配像素分辨率）
            canvas.style.width = canvasWidth + 'px';
            canvas.style.height = canvasHeight + 'px';
            
            // 居中显示
            canvas.style.position = 'absolute';
            canvas.style.left = '50%';
            canvas.style.top = '50%';
            canvas.style.transform = 'translate(-50%, -50%)';
            
            console.log(`[Canvas] Resized to ${canvasWidth}x${canvasHeight} (target: ${targetWidth}x${targetHeight}, window: ${windowWidth}x${windowHeight})`);
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // ===== Shader Compilation =====
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                const error = gl.getShaderInfoLog(shader);
                gl.deleteShader(shader);
                throw new Error(error);
            }
            
            return shader;
        }
        
        function createProgram(vertexSource, fragmentSource) {
            const compileStart = performance.now();
            
            try {
                const vertexShader = compileShader(vertexSource, gl.VERTEX_SHADER);
                const fragmentShader = compileShader(fragmentSource, gl.FRAGMENT_SHADER);
                
                const prog = gl.createProgram();
                gl.attachShader(prog, vertexShader);
                gl.attachShader(prog, fragmentShader);
                gl.linkProgram(prog);
                
                if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
                    const error = gl.getProgramInfoLog(prog);
                    throw new Error('Program linking failed:\n' + error);
                }
                
                const compileTime = performance.now() - compileStart;
                compiletimeElement.textContent = `Compile: ${compileTime.toFixed(1)}ms`;
                
                return prog;
            } catch (e) {
                showError(e.message);
                throw e;
            }
        }
        
        // ===== Uniform Setup =====
        function setupUniforms(prog) {
            gl.useProgram(prog);
            return {
                iResolution: gl.getUniformLocation(prog, 'iResolution'),
                iTime: gl.getUniformLocation(prog, 'iTime'),
                iTimeDelta: gl.getUniformLocation(prog, 'iTimeDelta'),
                iFrame: gl.getUniformLocation(prog, 'iFrame'),
                iMouse: gl.getUniformLocation(prog, 'iMouse'),
                iDate: gl.getUniformLocation(prog, 'iDate')
            };
        }
        
        // ===== Error Display =====
        function showError(message) {
            errorMessageElement.textContent = message;
            errorElement.style.display = 'block';
            console.error('Shader Error:', message);
        }
        
        function hideError() {
            errorElement.style.display = 'none';
        }
        
        // ===== Initialize Shader Program =====
        function initShaders() {
            const vertexSource = document.getElementById('vertexShader').textContent.trim();
            const fragmentSource = document.getElementById('fragmentShader').textContent.trim();
            
            program = createProgram(vertexSource, fragmentSource);
            uniforms = setupUniforms(program);
            hideError();
        }
        
        // ===== Update Uniforms =====
        function updateUniforms(time, deltaTime, frame) {
            gl.useProgram(program);
            
            // iResolution: viewport resolution (width, height, pixel ratio)
            gl.uniform3f(uniforms.iResolution, canvas.width, canvas.height, window.devicePixelRatio || 1.0);
            
            // iTime: shader playback time (seconds)
            gl.uniform1f(uniforms.iTime, time);
            
            // iTimeDelta: time since last frame (seconds)
            gl.uniform1f(uniforms.iTimeDelta, deltaTime);
            
            // iFrame: frame counter
            gl.uniform1i(uniforms.iFrame, frame);
            
            // iMouse: mouse position (xy = current, zw = click)
            // TODO: Will be implemented when adding mouse interaction
            gl.uniform4f(uniforms.iMouse, 0, 0, 0, 0);
            
            // iDate: current date (year, month, day, time in seconds)
            const now = new Date();
            const timeOfDay = now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds() + now.getMilliseconds() * 0.001;
            gl.uniform4f(uniforms.iDate, now.getFullYear(), now.getMonth(), now.getDate(), timeOfDay);
        }
        
        // ===== FPS Calculation =====
        function updateFPS() {
            fpsFrameCount++;
            const now = performance.now();
            const elapsed = now - lastFpsUpdate;
            
            if (elapsed >= 500) { // Update every 500ms
                currentFps = Math.round((fpsFrameCount * 1000) / elapsed);
                fpsElement.textContent = `FPS: ${currentFps}`;
                fpsFrameCount = 0;
                lastFpsUpdate = now;
            }
        }
        
        // ===== Render Loop =====
        function render() {
            requestAnimationFrame(render);
            
            if (!program) return;
            
            const now = performance.now();
            const deltaTime = (now - lastFrameTime) * 0.001; // Convert to seconds
            const time = (now - startTime) * 0.001;
            
            // Update frame time stat
            currentFrameTime = now - lastFrameTime;
            frametimeElement.textContent = `Frame: ${currentFrameTime.toFixed(1)}ms`;
            lastFrameTime = now;
            
            // Clear canvas
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            // Update uniforms
            updateUniforms(time, deltaTime, frameCounter);
            
            // Render fullscreen quad
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            // Increment frame counter
            frameCounter++;
            
            // Update FPS
            updateFPS();
        }
        
        // ===== Public API for Dynamic Shader Loading =====
        window.loadShader = function(fragmentShaderSource) {
            try {
                console.log('[WebGL] Starting shader compilation...');
                const vertexSource = document.getElementById('vertexShader').textContent.trim();
                
                // 删除旧的program（如果存在）
                if (program) {
                    gl.deleteProgram(program);
                }
                
                // 编译新的shader程序
                program = createProgram(vertexSource, fragmentShaderSource);
                uniforms = setupUniforms(program);
                
                // 重置时间和帧计数器，让动画效果更明显
                startTime = performance.now();
                frameCounter = 0;
                
                hideError();
                console.log('[WebGL] Shader loaded and compiled successfully!');
                console.log('[WebGL] Animation restarted from time 0');
            } catch (e) {
                console.error('[WebGL] Failed to load shader:', e);
                showError(e.message || String(e));
            }
        };
        
        // ===== Public API for Resolution Update =====
        /**
         * 设置目标分辨率
         * 会触发canvas重新计算尺寸
         * 
         * @param {number} width - 目标宽度
         * @param {number} height - 目标高度
         */
        window.setTargetResolution = function(width, height) {
            console.log(`[Resolution] Setting target resolution to ${width}x${height}`);
            
            targetWidth = width;
            targetHeight = height;
            
            // 重新计算canvas尺寸
            resizeCanvas();
            
            console.log(`[Resolution] Canvas resized, new size: ${canvas.width}x${canvas.height}`);
        };
        
        // ===== Initialize and Start =====
        try {
            initShaders();
            console.log('Shadertoy renderer initialized');
            console.log('WebGL 2 supported');
            console.log('Canvas size:', canvas.width, 'x', canvas.height);
            
            // Set clear color to black
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            
            // Start render loop
            startTime = performance.now();
            render();
        } catch (e) {
            console.error('Initialization failed:', e);
        }
    </script>
</body>
</html>

